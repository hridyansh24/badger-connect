Badger Connect implementation notes
==================================

Overview
--------
We rebuilt the entire repo with a fresh Vite + React + TypeScript stack and designed a three-step experience: login (wisc.edu only, optional interests with a campus-safe filter that loads from `public/banned-interests.txt`), mode selection (text vs video) with UW branding, and simulated text + video chat lounges. Styling lives in `src/App.css`/`src/index.css` and follows the red/white theme. All data is “profile based”—each simulated partner now has a name, email, interests, and bio so the UI enforces campus identity even before we wire in real services.

Key client features
-------------------
1. Login page (`src/pages/LoginPage.tsx`)
   - Validates name + `@wisc.edu` email, optional interests, banned-interest check, and redirects to `/mode`.
   - University crest + dark gradient per your branding request.
2. Mode selection (`src/pages/ModeSelectionPage.tsx`)
   - Enlarged layout, same gradient background, optional interest messaging.
   - CTA cards for text/video; logout available here.
3. Text chat (`src/pages/TextChatPage.tsx`)
   - Simulated matching/partner data, session IDs, chat bubbles, composer, and camera/pill design.
   - Reaction panel (like/dislike/report) drives a central reputation system that bans accounts at 3 reports or 10 dislikes.
   - Profile card + match context + connection status pill.
4. Video chat (`src/pages/VideoChatPage.tsx`)
   - Real camera preview via `getUserMedia`, remote preview placeholder, and same reaction/profile UX as text chat.
5. Reputation + banned list
   - `src/context/FeedbackContext.tsx` centralizes likes/dislikes/reports and spreads them across pages. Bans currently live in memory (reset on refresh) but the logic mirrors what the backend will enforce later.
6. Interest filters
   - `useBannedInterests` fetches `public/banned-interests.txt` so you can add new blocked words without code changes.

Realtime/WebSocket prep
-----------------------
- Installed `socket.io-client` and created `src/context/SocketContext.tsx`. It connects to `VITE_SOCKET_URL` (default `http://localhost:4000`) and exposes `status`, `error`, and a `send` helper.
- Text and video chat pages emit events:
  * `match:request` when searching for a partner.
  * `match:paired` when a simulated partner is assigned.
  * `chat:text:message` on every outbound text message.
  * `chat:leave` when a user exits the chat.
  * `profile:reaction` for likes/dislikes/reports with current totals.
- Both pages show a “Realtime link” card so you can see if the socket is connected; once a backend is live, you can listen to these events and respond appropriately.

What still needs backend work
-----------------------------
1. Real authentication: integrate UW’s SSO/OAuth (NetID) so users verify identity server-side before hitting the app. The current login only validates on the client.
2. Data persistence: set up a database/tables for profiles, interests, matches, reaction counts, and ban status. Sync `FeedbackContext` data to that backend so bans survive refreshes and apply globally.
3. Matchmaking + chat/video signaling: build a Node/Express (or similar) server with Socket.IO/WebRTC. Handle events we already emit (`match:request`, `match:paired`, etc.), broadcast partner messages, and manage session lifecycles. Add TURN/STUN infrastructure for WebRTC video.
4. Reporting enforcement: when the backend sees 3 reports or 10 dislikes (or manual admin action), flag the account as banned and prevent it from joining new chats. Update the frontend to consume that status via API/WS events.
5. Deployment: host the frontend (Netlify/Vercel/GitHub Pages) and backend (Render/Fly/Heroku/etc.) with HTTPS so cameras/mics work. Configure `VITE_SOCKET_URL` to point at the deployed signaling server.
6. Optional enhancements: persistent chat history, real-time typing indicators, queue status, admin dashboard for reports, notifications when a partner leaves, etc.

Next steps / action plan
------------------------
1. Stand up a simple backend skeleton (Node + Express + Socket.IO).
   - Define endpoints for login (backed by UW auth or temporary token).
   - Implement in-memory data structures mirroring `FeedbackContext` so you can test report persistence.
2. Wire the frontend to backend APIs.
   - Replace the simulated partner selection with actual matchmaking responses from the server.
   - Listen for server-emitted events (messages, partner join/leave) via the socket hook.
3. Add persistent storage.
   - Move from in-memory to a database (Postgres, Mongo, etc.) for profiles/interests/reactions.
4. Harden bans + admin tools.
   - Ensure banned users can’t log in or start sessions.
   - Create a simple admin view/API to review reported users.
5. Deploy everything.
   - Configure `.env`/`VITE_SOCKET_URL` for production.
   - Set up CI/CD so pushes rebuild the frontend and redeploy the backend.
6. QA and polish.
   - Test across browsers and networks (especially WebRTC camera/permissions).
   - Gather feedback from a small cohort before sharing campus-wide.

Keep this file handy as your checklist whenever you reopen the repo. Update it as you finish backend milestones or adjust the roadmap.
