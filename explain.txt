Badger Connect implementation notes
==================================

Overview
--------
We rebuilt the entire repo with a fresh Vite + React + TypeScript stack and designed a three-step experience: login (wisc.edu only, optional interests with a campus-safe filter that loads from `public/banned-interests.txt`), mode selection (text vs video) with UW branding, and simulated text + video chat lounges. Styling lives in `src/App.css`/`src/index.css` and follows the red/white theme. All data is “profile based”—each simulated partner now has a name, email, interests, and bio so the UI enforces campus identity even before we wire in real services.

Key client features
-------------------
1. Login page (`src/pages/LoginPage.tsx`)
   - Validates name + `@wisc.edu` email, optional interests, banned-interest check, and redirects to `/mode`.
   - University crest + dark gradient per your branding request.
2. Mode selection (`src/pages/ModeSelectionPage.tsx`)
   - Enlarged layout, same gradient background, optional interest messaging.
   - CTA cards for text/video; logout available here.
3. Text chat (`src/pages/TextChatPage.tsx`)
   - Live Socket.IO pairing when the backend is reachable; falls back to local simulation if the socket fails.
   - Session IDs, chat bubbles, composer, real-time status indicator, and “connected with {name}” system messages.
4. Video chat (`src/pages/VideoChatPage.tsx`)
   - Real camera preview via `getUserMedia`, remote preview placeholder, and the same reaction/profile UX as text chat.
5. Reputation + banned list
   - `src/context/FeedbackContext.tsx` centralizes likes/dislikes/reports with an auto-ban at 3 reports or 10 dislikes. Data is still in-memory client side but also syncs to the backend events.
6. Interest filters
   - `useBannedInterests` fetches `public/banned-interests.txt` so you can add new blocked words without code changes.

Realtime/WebSocket prep
-----------------------
- Installed `socket.io-client` and created `src/context/SocketContext.tsx`. It connects to `import.meta.env.VITE_SOCKET_URL` (default `http://localhost:4000`) and exposes `status`, `error`, and a `send` helper.
- Chat pages emit/listen for:
  * `profile:update` once the user logs in.
  * `match:request`, `match:paired`, `match:queued` for matchmaking flows.
  * `chat:text:message`, `chat:leave`, and `system:partner-left` for messaging lifecycle.
  * `profile:reaction` to sync likes/dislikes/reports back to the backend so bans apply globally.
- UI shows “Realtime link” so you always know whether the socket is connected.

Backend summary (backend/server.js)
-----------------------------------
- Express + Socket.IO server with CORS configuration via `CLIENT_ORIGIN`.
- Keeps separate queues for text/video modes, pairs users when two are waiting, and emits `match:paired` with basic partner info.
- Relays text messages between the two sockets within a session, handles disconnects, and broadcasts when a partner leaves.
- Stores reputation / bans in-memory so reports/dislikes accumulate across sessions while the server runs.
- REST endpoints: `/health` (queue stats) and `/reputation/:email` (current counts).

How to run locally (single laptop)
----------------------------------
1. **Backend**
   ```bash
   cd backend
   cat <<'EOF' > .env
   PORT=4000
   CLIENT_ORIGIN=http://localhost:5173
   EOF
   npm run dev
   ```
2. **Frontend**
   ```bash
   cd /Users/hridyanshsethi/badger_connect
   cat <<'EOF' > .env
   VITE_SOCKET_URL=http://localhost:4000
   EOF
   npm run dev
   ```
3. Visit `http://localhost:5173` in a browser; the “Realtime link” pill should show `connected` if the backend is running.

How to host on your LAN (share with a friend on same Wi-Fi)
-----------------------------------------------------------
1. Update both env files to use your LAN IP (e.g., `10.140.23.4`).
   - `backend/.env`
     ```
     PORT=4000
     CLIENT_ORIGIN=http://localhost:5173,http://10.140.23.4:5173
     ```
   - `.env`
     ```
     VITE_SOCKET_URL=http://10.140.23.4:4000
     ```
2. Restart both servers:
   - Backend: `cd backend && npm run dev`
   - Frontend: `npm run dev -- --host 0.0.0.0`
3. Share the `Network` URL Vite prints (e.g., `http://10.140.23.4:5173/`). Both browsers must be on the same Wi-Fi and on `/chat/text` at the same time to pair. Cameras require HTTPS or localhost.

Deployment / next steps
------------------------
1. Harden authentication: hook up UW SSO or email verification server-side so the client login can’t be bypassed.
2. Persist data: move reputation, interests, and session history to a real database (Postgres, MongoDB, etc.) so bans survive restarts.
3. Real WebRTC signaling: extend the backend so video chat actually relays SDP/ICE candidates and uses TURN/STUN for media.
4. Add admin tooling: API or dashboard to review reported profiles, manually unban, etc.
5. Deploy front + back: push the frontend to Netlify/Vercel and the backend to a host (Render, Fly, EC2) with HTTPS. Update `VITE_SOCKET_URL` to the public backend URL.
6. Testing & monitoring: add server logging, heartbeat pings, unit tests for queue logic, automated deployment scripts, etc.

Keep this file updated as you tackle the roadmap. The commands above are all you need to spin the project up again on localhost or over Wi-Fi.
